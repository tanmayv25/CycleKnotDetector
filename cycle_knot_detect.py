# -*- generated by 1.0.12 -*-
import da
PatternExpr_307 = da.pat.TuplePattern([da.pat.ConstantPattern('Request'), da.pat.FreePattern('sender')])
PatternExpr_428 = da.pat.TuplePattern([da.pat.ConstantPattern('message_count'), da.pat.FreePattern('message_count')])
PatternExpr_451 = da.pat.TuplePattern([da.pat.ConstantPattern('Reply'), da.pat.FreePattern('type'), da.pat.FreePattern('sender'), da.pat.FreePattern('S')])
PatternExpr_949 = da.pat.ConstantPattern('Terminate')
PatternExpr_973 = da.pat.ConstantPattern('Terminate_initiator')
PatternExpr_953 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Terminate')])
PatternExpr_977 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Terminate_initiator')])
_config_object = {}
import sys
import graph_config
import random

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PReceivedEvent_3 = []
        self._PReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_307, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_306]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_428, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_427]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_2', PatternExpr_451, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_450]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_3', PatternExpr_949, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_4', PatternExpr_973, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, successors, own_id, all_processors, initiator_id, initiator, no_of_edges, node_type, **rest_1373):
        super().setup(successors=successors, own_id=own_id, all_processors=all_processors, initiator_id=initiator_id, initiator=initiator, no_of_edges=no_of_edges, node_type=node_type, **rest_1373)
        self._state.successors = successors
        self._state.own_id = own_id
        self._state.all_processors = all_processors
        self._state.initiator_id = initiator_id
        self._state.initiator = initiator
        self._state.no_of_edges = no_of_edges
        self._state.node_type = node_type
        self._state.mode = 'sleep'
        self._state.status = 'undefined'
        self._state.num_suc = 0
        self._state.initiator_sent_cycle_message = False
        self._state.has_terminated_earlier = False
        self._state.has_sent_incomplete_search = False
        self._state.S_sent_with_termination = set()
        self._state.type_sent_with_termination = ''
        self._state.this_S = {}
        self._state.result = 'unknown'
        self._state.parent = self._id
        self._state.message_count = 0
        self._state.total_message_count = 0
        self._state.no_of_nodes = len(self._state.all_processors)
        self._state.replies_received = {'cycle': 0, 'cycle_only': 0, 'incomplete_search': 0, 'leaf': 0}

    def run(self):
        self.initiate()
        super()._label('_st_label_946', block=False)
        _st_label_946 = 0
        while (_st_label_946 == 0):
            _st_label_946 += 1
            if PatternExpr_953.match_iter(self._PReceivedEvent_3, SELF_ID=self._id):
                _st_label_946 += 1
            else:
                super()._label('_st_label_946', block=True)
                _st_label_946 -= 1
        if (self._state.own_id == self._state.initiator_id):
            self._state.total_message_count += self._state.message_count
            super()._label('_st_label_970', block=False)
            _st_label_970 = 0
            while (_st_label_970 == 0):
                _st_label_970 += 1
                if PatternExpr_977.match_iter(self._PReceivedEvent_4, SELF_ID=self._id):
                    _st_label_970 += 1
                else:
                    super()._label('_st_label_970', block=True)
                    _st_label_970 -= 1
            self.output('Total no of message:', self._state.total_message_count)
            if (self._state.total_message_count > (2 * self._state.no_of_edges)):
                self.output('Test case failed')
        else:
            self.send(('message_count', self._state.message_count), to=self._state.initiator)

    def initiate(self):
        if (self._state.own_id == self._state.initiator_id):
            self._state.mode = 'awake'
            self._state.num_suc = len(self._state.successors)
            self.send(('Request', self._id), to=self._state.successors)

    def _P_handler_306(self, sender):
        self._state.message_count += 1

        def bar(i):
            return ((- 1) * i)
        if (self._state.own_id == self._state.initiator_id):
            S = set()
            if self._state.initiator_sent_cycle_message:
                S.add(bar(self._state.own_id))
            self._state.initiator_sent_cycle_message = True
            self.send(('Reply', 'cycle', self._id, S), to=sender)
        elif self._state.has_terminated_earlier:
            self.send(('Reply', self._state.type_sent_with_termination, self._id, self._state.S_sent_with_termination), to=sender)
        elif (self._state.mode == 'awake'):
            self._state.has_sent_incomplete_search = True
            pk = set()
            pk.add(self._state.own_id)
            self.send(('Reply', 'incomplete_search', self._id, pk), to=sender)
        elif (len(self._state.successors) == 0):
            S = set()
            self._state.status = 'leaf'
            self.send(('Reply', 'leaf', self._id, S), to=sender)
        else:
            self._state.parent = sender
            self._state.mode = 'awake'
            self._state.num_suc = len(self._state.successors)
            self.send(('Request', self._id), to=self._state.successors)
    _P_handler_306._labels = None
    _P_handler_306._notlabels = None

    def _P_handler_427(self, message_count):
        self._state.total_message_count += message_count
        self._state.no_of_nodes -= 1
        if (self._state.no_of_nodes == 1):
            self.send('Terminate_initiator', to=self._state.initiator)
    _P_handler_427._labels = None
    _P_handler_427._notlabels = None

    def _P_handler_450(self, type, sender, S):
        self._state.message_count += 1

        def bar(i):
            return ((- 1) * i)

        def set_union(S1, S2):
            for i in S1:
                if ((i < 0) and (((- 1) * i) in S2)):
                    S2.remove(((- 1) * i))
            for i in S2:
                if ((i < 0) and (((- 1) * i) in S1)):
                    S1.remove(((- 1) * i))
            U = S1.union(S2)
            return U

        def type_exor(type1, type2):
            if (((type2 == 'cycle_only') or (type1 == 'cycle_only')) or ((type1 == 'cycle') and (type2 == 'leaf')) or ((type2 == 'cycle') and (type1 == 'leaf'))):
                return 'cycle_only'
            elif (((type1 == 'cycle') and (type2 == 'incomplete_search')) or ((type2 == 'cycle') and (type1 == 'incomplete_search'))):
                return 'cycle'
            elif (((type1 == 'leaf') and (type2 == 'incomplete_search')) or ((type2 == 'leaf') and (type1 == 'incomplete_search'))):
                return 'leaf'
            else:
                return type1
        self._state.num_suc -= 1
        if (sender in self._state.this_S):
            self._state.this_S[sender] = set_union(self._state.this_S[sender], S)
        else:
            self._state.this_S[sender] = S
        if (self._state.status == 'undefined'):
            self._state.status = type
        else:
            self._state.status = type_exor(self._state.status, type)
        if (self._state.num_suc == 0):
            new_set = set()
            for set_j in self._state.this_S.values():
                new_set = set_union(new_set, set_j)
            unmarked_elements = [i for i in new_set if (i > 0)]
            marked_elements = [i for i in new_set if (i < 0)]
            if (self._state.own_id == self._state.initiator_id):
                if (self._state.status == 'cycle_only'):
                    self._state.result = 'cycle'
                elif ((self._state.status == 'cycle') and (len(new_set) == 0)):
                    self._state.result = 'cycle'
                elif ((self._state.status == 'cycle') and (len(unmarked_elements) == 0) and (len(marked_elements) > 0)):
                    self._state.result = 'knot'
                else:
                    self._state.result = 'Neither Cycle nor Knot'
                self.output('The Initiator node is inside a:', self._state.result)
                if ((not (self._state.node_type == 'Unknown')) and (not (self._state.node_type == self._state.result))):
                    self.output('Function Testing failed!!!')
                self.send('Terminate', to=self._state.all_processors)
            else:
                self._state.replies_received[type] = 1
                if self._state.has_sent_incomplete_search:
                    pk_bar = set()
                    pk_bar.add(bar(self._state.own_id))
                    new_set = set_union(new_set, pk_bar)
                self._state.has_terminated_earlier = True
                self._state.S_sent_with_termination = new_set
                unmarked_elements = [i for i in new_set if (i > 0)]
                marked_elements = [i for i in new_set if (i < 0)]
                empty_set = set()
                if ((self._state.status == 'leaf') or ((self._state.status == 'incomplete_search') and (len(unmarked_elements) == 0) and (len(marked_elements) > 0))):
                    self._state.S_sent_with_termination = empty_set
                    self._state.type_sent_with_termination = 'leaf'
                    self.send(('Reply', 'leaf', self._id, empty_set), to=self._state.parent)
                if ((self._state.status == 'incomplete_search') and (len(unmarked_elements) > 0)):
                    self._state.type_sent_with_termination = 'incomplete_search'
                    self.send(('Reply', 'incomplete_search', self._id, new_set), to=self._state.parent)
                if (self._state.status == 'cycle_only'):
                    self._state.S_sent_with_termination = empty_set
                    self._state.type_sent_with_termination = 'cycle_only'
                    self.send(('Reply', 'cycle_only', self._id, empty_set), to=self._state.parent)
                if (self._state.status == 'cycle'):
                    if ((self._state.replies_received['cycle'] == 1) and (self._state.replies_received['cycle_only'] == 0) and (self._state.replies_received['incomplete_search'] == 0) and (self._state.replies_received['leaf'] == 0)):
                        self._state.type_sent_with_termination = 'cycle'
                        self.send(('Reply', 'cycle', self._id, new_set), to=self._state.parent)
                    elif ((len(unmarked_elements) == 0) and (len(marked_elements) > 0)):
                        self._state.type_sent_with_termination = 'cycle_only'
                        self.send(('Reply', 'cycle_only', self._id, new_set), to=self._state.parent)
                    else:
                        self._state.type_sent_with_termination = 'cycle'
                        self.send(('Reply', 'cycle', self._id, new_set), to=self._state.parent)
    _P_handler_450._labels = None
    _P_handler_450._notlabels = None

def create_graph(n):
    no_of_edges = 0
    successors = ([1] * n)
    for i in range(n):
        k = random.randint(5, n)
        S = set()
        for j in range(1, k):
            l = random.randint(1, k)
            if (not (i == l)):
                S.add(l)
        successors[i] = S
        no_of_edges += len(successors[i])
    return (successors, no_of_edges)

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'fifo'}

    def run(self):

        def Functional_testing_with_rings_and_knots():
            for n in range(10, 500, 10):
                for node_type in ['cycle', 'knot']:
                    ps = list(self.new(P, num=n))
                    no_of_edges = 0
                    for (i, p) in enumerate(ps):
                        if (node_type == 'cycle'):
                            successors = [ps[((i + 1) if (i < (len(ps) - 1)) else 0)]]
                        elif (node_type == 'knot'):
                            if (i == (len(ps) - 4)):
                                successors = [ps[(i + 1)], ps[(i + 2)]]
                            elif (i == (len(ps) - 3)):
                                successors = [ps[0]]
                            else:
                                successors = [ps[((i + 1) if (i < (len(ps) - 1)) else 0)]]
                        no_of_edges += len(successors)
                        self._setup({p}, (successors, (i + 1), ps, 1, ps[0], no_of_edges, node_type))
                    self._start(ps)
                    self.output('Total no of Edges:', no_of_edges)

        def scalability_testing_random_graphs():
            for N in range(10, 100):
                ps = list(self.new(P, num=N))
                initiator_id = 1
                (graph, no_of_edges) = create_graph(N)
                self.output('Total no of Edges:', no_of_edges)
                for (i, p) in enumerate(ps):
                    successors = [ps[(i - 1)] for i in graph[i]]
                    self._setup({p}, (successors, (i + 1), ps, 1, ps[0], no_of_edges, 'Unknown'))
                self._start(ps)

        def Manual_testing():
            n = graph_config.test['total_nodes']
            ps = list(self.new(P, num=n))
            for (i, p) in enumerate(ps):
                successors = [ps[(i - 1)] for i in graph_config.test[('node' + str((i + 1)))]]
                self._setup({p}, (successors, (i + 1), ps, graph_config.test['initiator']))
            self._start(ps)
        Functional_testing_with_rings_and_knots()
