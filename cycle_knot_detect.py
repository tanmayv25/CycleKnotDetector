# -*- generated by 1.0.12 -*-
import da
PatternExpr_278 = da.pat.TuplePattern([da.pat.ConstantPattern('Request'), da.pat.FreePattern('sender')])
PatternExpr_400 = da.pat.TuplePattern([da.pat.ConstantPattern('Reply'), da.pat.FreePattern('type'), da.pat.FreePattern('sender'), da.pat.FreePattern('S')])
PatternExpr_892 = da.pat.ConstantPattern('Terminate')
PatternExpr_896 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Terminate')])
_config_object = {}
import sys
import graph_config

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_278, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_277]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_400, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_399]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_2', PatternExpr_892, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, successors, own_id, all_processors, initiator, **rest_976):
        super().setup(successors=successors, own_id=own_id, all_processors=all_processors, initiator=initiator, **rest_976)
        self._state.successors = successors
        self._state.own_id = own_id
        self._state.all_processors = all_processors
        self._state.initiator = initiator
        self._state.mode = 'sleep'
        self._state.status = 'undefined'
        self._state.num_suc = 0
        self._state.initiator_sent_cycle_message = False
        self._state.has_terminated_earlier = False
        self._state.has_sent_incomplete_search = False
        self._state.S_sent_with_termination = set()
        self._state.type_sent_with_termination = ''
        self._state.this_S = {}
        self._state.result = 'unknown'
        self._state.parent = self._id
        self._state.replies_received = {'cycle': 0, 'cycle_only': 0, 'incomplete_search': 0, 'leaf': 0}

    def run(self):
        self.initiate()
        super()._label('_st_label_889', block=False)
        _st_label_889 = 0
        while (_st_label_889 == 0):
            _st_label_889 += 1
            if PatternExpr_896.match_iter(self._PReceivedEvent_2, SELF_ID=self._id):
                _st_label_889 += 1
            else:
                super()._label('_st_label_889', block=True)
                _st_label_889 -= 1
        self.output('Done!!!')

    def initiate(self):
        if (self._state.own_id == self._state.initiator):
            self._state.mode = 'awake'
            self._state.num_suc = len(self._state.successors)
            self.send(('Request', self._id), to=self._state.successors)

    def _P_handler_277(self, sender):
        self.output('Request', self._state.own_id, sep='     ')

        def bar(i):
            return ((- 1) * i)
        if (self._state.own_id == self._state.initiator):
            S = set()
            if self._state.initiator_sent_cycle_message:
                S.add(bar(self._state.own_id))
            self._state.initiator_sent_cycle_message = True
            self.send(('Reply', 'cycle', self._id, S), to=sender)
        elif self._state.has_terminated_earlier:
            self.send(('Reply', self._state.type_sent_with_termination, self._id, self._state.S_sent_with_termination), to=sender)
        elif (self._state.mode == 'awake'):
            self._state.has_sent_incomplete_search = True
            pk = set()
            pk.add(self._state.own_id)
            self.send(('Reply', 'incomplete_search', self._id, pk), to=sender)
        elif (len(self._state.successors) == 0):
            S = set()
            self._state.status = 'leaf'
            self.send(('Reply', 'leaf', self._id, S), to=sender)
        else:
            self._state.parent = sender
            self._state.mode = 'awake'
            self._state.num_suc = len(self._state.successors)
            self.send(('Request', self._id), to=self._state.successors)
    _P_handler_277._labels = None
    _P_handler_277._notlabels = None

    def _P_handler_399(self, type, sender, S):
        self.output('Reply', type, self._state.own_id, S, sep='     ')

        def bar(i):
            return ((- 1) * i)

        def set_union(S1, S2):
            for i in S1:
                if ((i < 0) and (((- 1) * i) in S2)):
                    S2.remove(((- 1) * i))
            for i in S2:
                if ((i < 0) and (((- 1) * i) in S1)):
                    S1.remove(((- 1) * i))
            U = S1.union(S2)
            return U

        def type_exor(type1, type2):
            self.output(type1, type2)
            if (((type2 == 'cycle_only') or (type1 == 'cycle_only')) or ((type1 == 'cycle') and (type2 == 'leaf')) or ((type2 == 'cycle') and (type1 == 'leaf'))):
                return 'cycle_only'
            elif (((type1 == 'cycle') and (type2 == 'incomplete_search')) or ((type2 == 'cycle') and (type1 == 'incomplete_search'))):
                return 'cycle'
            elif (((type1 == 'leaf') and (type2 == 'incomplete_search')) or ((type2 == 'leaf') and (type1 == 'incomplete_search'))):
                return 'leaf'
            else:
                return type1
        self._state.num_suc -= 1
        if (sender in self._state.this_S):
            self._state.this_S[sender] = set_union(self._state.this_S[sender], S)
        else:
            self._state.this_S[sender] = S
        if (self._state.status == 'undefined'):
            self._state.status = type
        else:
            self._state.status = type_exor(self._state.status, type)
        if (self._state.num_suc == 0):
            new_set = set()
            for set_j in self._state.this_S.values():
                new_set = set_union(new_set, set_j)
            unmarked_elements = [i for i in new_set if (i > 0)]
            marked_elements = [i for i in new_set if (i < 0)]
            if (self._state.own_id == self._state.initiator):
                if (self._state.status == 'cycle_only'):
                    self._state.result = 'cycle'
                elif ((self._state.status == 'cycle') and (len(new_set) == 0)):
                    self._state.result = 'cycle'
                elif ((self._state.status == 'cycle') and (len(unmarked_elements) == 0) and (len(marked_elements) > 0)):
                    self._state.result = 'knot'
                else:
                    self._state.result = 'Neither Cycle nor Knot'
                self.output('The Initiator node is inside a:', self._state.result)
                self.send('Terminate', to=self._state.all_processors)
            else:
                self._state.replies_received[type] = 1
                if self._state.has_sent_incomplete_search:
                    pk_bar = set()
                    pk_bar.add(bar(self._state.own_id))
                    new_set = set_union(new_set, pk_bar)
                self._state.has_terminated_earlier = True
                self._state.S_sent_with_termination = new_set
                unmarked_elements = [i for i in new_set if (i > 0)]
                marked_elements = [i for i in new_set if (i < 0)]
                empty_set = set()
                if ((self._state.status == 'leaf') or ((self._state.status == 'incomplete_search') and (len(unmarked_elements) == 0) and (len(marked_elements) > 0))):
                    self._state.S_sent_with_termination = empty_set
                    self._state.type_sent_with_termination = 'leaf'
                    self.send(('Reply', 'leaf', self._id, empty_set), to=self._state.parent)
                if ((self._state.status == 'incomplete_search') and (len(unmarked_elements) > 0)):
                    self._state.type_sent_with_termination = 'incomplete_search'
                    self.send(('Reply', 'incomplete_search', self._id, new_set), to=self._state.parent)
                if (self._state.status == 'cycle_only'):
                    self._state.S_sent_with_termination = empty_set
                    self._state.type_sent_with_termination = 'cycle_only'
                    self.send(('Reply', 'cycle_only', self._id, empty_set), to=self._state.parent)
                if (self._state.status == 'cycle'):
                    if ((self._state.replies_received['cycle'] == 1) and (self._state.replies_received['cycle_only'] == 0) and (self._state.replies_received['incomplete_search'] == 0) and (self._state.replies_received['leaf'] == 0)):
                        self._state.type_sent_with_termination = 'cycle'
                        self.send(('Reply', 'cycle', self._id, new_set), to=self._state.parent)
                    elif ((len(unmarked_elements) == 0) and (len(marked_elements) > 0)):
                        self._state.type_sent_with_termination = 'cycle_only'
                        self.send(('Reply', 'cycle_only', self._id, new_set), to=self._state.parent)
                    else:
                        self._state.type_sent_with_termination = 'cycle'
                        self.send(('Reply', 'cycle', self._id, new_set), to=self._state.parent)
    _P_handler_399._labels = None
    _P_handler_399._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'fifo'}

    def run(self):
        n = graph_config.test['total_nodes']
        ps = list(self.new(P, num=n))
        for (i, p) in enumerate(ps):
            successors = [ps[(i - 1)] for i in graph_config.test[('node' + str((i + 1)))]]
            self._setup({p}, (successors, (i + 1), ps, graph_config.test['initiator']))
        self._start(ps)
