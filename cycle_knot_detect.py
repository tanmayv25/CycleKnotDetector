# -*- generated by 1.0.12 -*-
import da
PatternExpr_206 = da.pat.TuplePattern([da.pat.ConstantPattern('broadcast'), da.pat.FreePattern('id')])
PatternExpr_256 = da.pat.TuplePattern([da.pat.ConstantPattern('Terminate')])
PatternExpr_261 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('Terminate')])])
_config_object = {}
import sys
import graph_config

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_206, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_205]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_256, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ps, successors, own_id, **rest_337):
        super().setup(ps=ps, successors=successors, own_id=own_id, **rest_337)
        self._state.ps = ps
        self._state.successors = successors
        self._state.own_id = own_id
        self._state.mode = 'sleep'
        self._state.status = 'undefined'
        self._state.num_suc = 0

    def run(self):
        self.initiate()
        self.output('YO from ', self._id)
        super()._label('_st_label_253', block=False)
        _st_label_253 = 0
        while (_st_label_253 == 0):
            _st_label_253 += 1
            if PatternExpr_261.match_iter(self._PReceivedEvent_1, SELF_ID=self._id):
                _st_label_253 += 1
            else:
                super()._label('_st_label_253', block=True)
                _st_label_253 -= 1
        self.output('Done! from ', self._id)

    def initiate(self):
        if (self._state.own_id == 0):
            self.send(('broadcast', self._state.own_id), to=self._state.successors)

    def _P_handler_205(self, id):
        if (self._state.mode == 'sleep'):
            self.output((self._state.own_id + 1), ' received signal from ', (id + 1))
            self.send(('broadcast', self._state.own_id), to=self._state.successors)
            self._state.mode = 'awake'
        else:
            self.output('About to terminate')
            self.send(('Terminate',), to=self._id)
    _P_handler_205._labels = None
    _P_handler_205._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'fifo'}

    def run(self):
        n = graph_config.network1['total_nodes']
        ps = list(self.new(P, num=n))
        for (i, p) in enumerate(ps):
            successors = [ps[(i - 1)] for i in graph_config.network1[('node' + str((i + 1)))]]
            self._setup({p}, (ps, successors, i))
        self._start(ps)
